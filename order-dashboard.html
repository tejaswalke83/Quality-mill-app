<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Order Dashboard</title>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>  
  <link href="https://fonts.googleapis.com/css2?family=Inter&display=swap" rel="stylesheet">
  <script defer src="/common.js"></script>
</head>
<body class="bg-gray-100 min-h-screen p-6">
  <h1 class="text-2xl font-bold text-center mb-6">Order Dashboard</h1>

  <!-- Controls -->
  <div class="bg-white shadow rounded-lg p-4 mb-6">
    <div class="flex flex-wrap items-center gap-3 mb-4">
      <input 
        type="text" id="searchBox"
        placeholder="Search by name, phone, token, total, status, grain..."
        oninput="handleSearchInput()" 
        class="flex-1 border border-gray-300 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
      />
      <button id="searchBtn" onclick="searchAndScroll()" disabled
        class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed">
        Search
      </button>
      <button onclick="resetSearch()" class="px-4 py-2 bg-gray-200 rounded hover:bg-gray-300">
        Reset
      </button>
    </div>

    <div class="flex flex-wrap items-center gap-3 filter-group text-sm"></div>

    <!-- NEW: Delivered totals accordion placeholder (injected by JS) -->
    <div id="deliveredTotalsWrapper" class="mt-4"></div>
  </div>

  <!-- Orders -->
  <div id="ordersList" class="space-y-4"></div>

  <!-- Fullscreen Popup -->
  <div id="orderModal" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center z-50">
    <div class="bg-white rounded-lg shadow-lg max-w-lg w-full p-6 relative">
      <button onclick="closeModal()" class="absolute top-2 right-2 text-gray-500 hover:text-gray-700">✖</button>
      <div id="modalContent"></div>
    </div>
  </div>

<script src="config.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<script>
  // Supabase guard: create window.supabaseClient only when config present and SDK loaded
  (function initSupabaseGuard(){
    const SUPABASE_URL = window._env_?.SUPABASE_URL ?? null;
    const SUPABASE_KEY = window._env_?.SUPABASE_ANON_KEY ?? null;

    console.groupCollapsed('[Supabase Guard]');
    console.log('window._env_ present?', !!window._env_);
    console.log('SUPABASE_URL host:', SUPABASE_URL ? (() => { try { return new URL(SUPABASE_URL).host } catch(e){ return SUPABASE_URL } })() : SUPABASE_URL);
    console.log('SUPABASE_KEY length:', SUPABASE_KEY ? SUPABASE_KEY.length : SUPABASE_KEY);
    console.groupEnd();

    const hasPlaceholder = (v) => !v || String(v).includes('%%') || String(v).trim() === '';

    if (hasPlaceholder(SUPABASE_URL) || hasPlaceholder(SUPABASE_KEY)) {
      console.error('[Supabase Guard] config.js missing or contains placeholders — not creating client.');
      window.supabaseClient = null;
      return;
    }

    if (window.supabase && typeof window.supabase.createClient === 'function') {
      if (!window.supabaseClient || !window.supabaseClient._initialized) {
        try {
          window.supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
          window.supabaseClient._initialized = true;
          console.log('[Supabase Guard] window.supabaseClient created for', new URL(SUPABASE_URL).host);
        } catch (err) {
          console.error('[Supabase Guard] failed to create client', err);
          window.supabaseClient = null;
        }
      } else {
        console.log('[Supabase Guard] reusing existing window.supabaseClient');
      }
    } else {
      console.warn('[Supabase Guard] supabase global SDK not loaded yet');
      window.supabaseClient = null;
    }
  })();
</script>

<script>
(async function(){
  const supabase = window.supabaseClient;

  if (!supabase) {
    console.warn('Supabase client not available — DB-backed UI disabled. Fix /config.js or loading order.');
    document.getElementById('ordersList').innerHTML =
      `<div class="bg-yellow-50 border border-yellow-200 rounded p-4 text-sm text-yellow-800">
         ⚠️ Supabase not configured. Check <code>/config.js</code> or environment injection. See console for details.
       </div>`;
    window.loadOrders = async () => {};
    window.loadFilterButtons = async () => {};
    window.initializeFlows = async () => {};
    window.handleSearchInput = () => {};
    window.searchAndScroll = async () => {};
    window.resetSearch = () => {};
    window.openModal = () => {};
    window.closeModal = () => {};
    window.updateOrderStatus = () => {};
    window.savePaymentMethod = () => {};
    return;
  }

  // ---------- Business logic ----------
  let statusesCache = [];
  let statusFlows = {};
  let currentOpenOrder = null;
  let searchTimeout;

  // cache role here
  window._currentUserRole = window._currentUserRole || null;

  // Helper: extract phone from URL query param
  function getPhoneFromUrl() {
    try {
      const qp = new URLSearchParams(window.location.search);
      const p = qp.get('phone') || qp.get('mobile') || qp.get('ph');
      return p ? String(p).trim() : null;
    } catch (e) {
      return null;
    }
  }

  // Helper: canonical phone getter for role resolution
  function getPhoneForRole() {
    // priority: URL param -> config -> localStorage -> body dataset -> global var
    const fromUrl = getPhoneFromUrl();
    const fromEnv = window._env_?.USER_PHONE ?? null;
    const fromLocal = localStorage.getItem('user_phone') ?? null;
    const fromBody = document.body?.dataset?.phone ?? null;
    const fromGlobal = window.loggedInPhone ?? window.currentUserPhone ?? null;

    window.debugRoleSources = {
      url_phone: fromUrl,
      env_USER_PHONE: fromEnv,
      local_user_phone: fromLocal,
      body_dataset_phone: fromBody,
      globals: { loggedInPhone: window.loggedInPhone ?? null, currentUserPhone: window.currentUserPhone ?? null }
    };

    return (fromUrl || fromEnv || fromLocal || fromBody || fromGlobal) || null;
  }

  // FINAL fetchUserRole() — queries public.users by phone_number (no supabase.auth)
  async function fetchUserRole() {
    if (window._currentUserRole) {
      console.debug('fetchUserRole: cached ->', window._currentUserRole);
      return window._currentUserRole;
    }

    const phone = getPhoneForRole();
    console.debug('fetchUserRole: resolved phone candidate ->', phone, window.debugRoleSources);

    if (!phone) {
      console.warn('fetchUserRole: no phone available to lookup role. Check URL ( ?phone= ), config, or localStorage.');
      return null;
    }

    const normalized = String(phone).replace(/[^\d]/g, '');

    try {
      const { data, error } = await supabase
        .from('users')
        .select('role')
        .eq('phone_number', normalized)
        .maybeSingle();

      window.debugRoleSources.users_table_lookup = { data, error };

      if (error) {
        console.error('fetchUserRole: error querying users table', error);
        return null;
      }
      if (data && data.role) {
        window._currentUserRole = String(data.role).toLowerCase();
        console.debug('fetchUserRole: resolved role from users table ->', window._currentUserRole);
        return window._currentUserRole;
      } else {
        try {
          const { data: d2, error: e2 } = await supabase
            .from('users')
            .select('role')
            .eq('phone_number', String(phone))
            .maybeSingle();
          window.debugRoleSources.users_table_lookup_fallback = { d2, e2 };
          if (!e2 && d2 && d2.role) {
            window._currentUserRole = String(d2.role).toLowerCase();
            console.debug('fetchUserRole: resolved role from users table (fallback match) ->', window._currentUserRole);
            return window._currentUserRole;
          }
        } catch (ex) {
          console.warn('fetchUserRole: fallback query failed', ex);
        }

        console.warn('fetchUserRole: no role found for phone', phone);
        return null;
      }
    } catch (e) {
      console.error('fetchUserRole failed:', e);
      return null;
    }
  }
  window.fetchUserRole = fetchUserRole; // expose for console

  function getStatusClass(status) {
    const map = {
      "NEW": "bg-yellow-100 text-yellow-800",
      "IN PROCESS": "bg-blue-100 text-blue-800",
      "MILLING COMPLETED": "bg-green-100 text-green-800",
      "DELIVERED": "bg-gray-200 text-gray-800",
      "PICKED UP": "bg-purple-100 text-purple-800",
      "RECEIVED AT MILL": "bg-orange-100 text-orange-800",
      "OUT FOR DELIVERY": "bg-pink-100 text-pink-800"
    };
    return map[status] || "bg-gray-100 text-gray-700";
  }

function getOrderTypeIcon(type) {
  if (!type) return "";
  const t = String(type).toLowerCase().trim().replace(/[_\s]+/g, '-');
  const pinwheelIcon = `<img src="https://openmoji.org/data/color/svg/1F33E.svg" class="order-icon w-7 h-7" />`;
  const scooterIcon  = `<img src="https://openmoji.org/data/color/svg/1F6F5.svg" class="order-icon w-7 h-7" />`;
  if (t.includes('home-buy-milling') || t.includes('home-buy-mill')) return pinwheelIcon + scooterIcon;
  if (t.includes('shop-buy-milling') || t.includes('shop-buy-mill')) return pinwheelIcon;
  if (t.includes('home-milling') || t.includes('home-mill')) return scooterIcon;
  return "";
}

  async function fetchAllOrders() {
    const { data, error } = await supabase
      .from('orders')
      .select(`
        *,
        customers(name, phone_number, milling_preference),
        order_statuses(status_name, sort_order, id)
      `)
      .order('created_at', { ascending: false });

    if (error) {
      console.error("fetchAllOrders error:", error);
      return [];
    }
    return data || [];
  }

  async function fetchStatuses() {
    const { data, error } = await supabase
      .from('order_statuses')
      .select('*')
      .order('sort_order', { ascending: true });

    if (error) {
      console.error("fetchStatuses error:", error);
      statusesCache = [];
    } else {
      statusesCache = data || [];
    }
    return statusesCache;
  }

  async function buildStatusFlows() {
    const statuses = await fetchStatuses();
    const statusMap = {};
    statuses.forEach(s => statusMap[s.status_name] = s.id);

    return {
      "shop-milling": [statusMap["NEW"], statusMap["IN PROCESS"], statusMap["MILLING COMPLETED"], statusMap["DELIVERED"]],
      "shop-buy-mill": [statusMap["NEW"], statusMap["IN PROCESS"], statusMap["MILLING COMPLETED"], statusMap["DELIVERED"]],
      "home-milling": [statusMap["NEW"], statusMap["PICKED UP"], statusMap["RECEIVED AT MILL"], statusMap["IN PROCESS"], statusMap["MILLING COMPLETED"], statusMap["OUT FOR DELIVERY"], statusMap["DELIVERED"]],
      "home-buy-mill": [statusMap["NEW"], statusMap["IN PROCESS"], statusMap["MILLING COMPLETED"], statusMap["OUT FOR DELIVERY"], statusMap["DELIVERED"]]
    };
  }

  async function initializeFlows() { statusFlows = await buildStatusFlows(); }

  function getNextStatus(order) {
    const flow = statusFlows[(order.order_type || '').toString()] || statusFlows[(order.order_type || '').toString().toLowerCase()] || [];
    const idx = flow.indexOf(order.status_id);
    if (idx === -1 || idx + 1 >= flow.length) return null;
    const nextId = flow[idx + 1];
    return statusesCache.find(s => s.id === nextId) || null;
  }

  // Strong authoritative guard in updateOrderStatus – server row + robust checks
  async function updateOrderStatus(orderId, newStatusId) {
    if (!Array.isArray(statusesCache) || statusesCache.length === 0) await fetchStatuses();

    let order;
    try {
      const { data: orderData, error: orderErr } = await supabase
        .from('orders')
        .select('id, order_type, status_id')
        .eq('id', orderId)
        .maybeSingle();
      if (orderErr) {
        console.warn('updateOrderStatus: order fetch error', orderErr);
        alert('Unable to validate order. Aborting update.');
        return;
      }
      order = orderData;
      if (!order) {
        alert('Order not found. Aborting update.');
        return;
      }
    } catch (e) {
      console.warn('updateOrderStatus: fetch failed', e);
      alert('Unable to validate order. Aborting update.');
      return;
    }

    const currentStatusName = (statusesCache.find(s => s.id === order.status_id)?.status_name || '').toString().trim().toUpperCase();
    const nextStatus = statusesCache.find(s => String(s.id) === String(newStatusId));
    const nextStatusName = (nextStatus?.status_name || '').toString().trim().toUpperCase();
    const orderTypeNorm = (order.order_type || '').toString().toLowerCase();

    let role = null;
    try { role = await fetchUserRole(); } catch (e) { console.warn('fetchUserRole failed', e); }

    console.debug('updateOrderStatus: guard check', { role, orderTypeNorm, currentStatusName, nextStatusName, orderId });

    const isHomeMilling = orderTypeNorm.includes('home') && orderTypeNorm.includes('mill');
    const isOperator = String(role||'').toLowerCase() === 'operator';
    const isFromNewToPicked = currentStatusName === 'NEW' && nextStatusName === 'PICKED UP';
    const isOutToDelivered = currentStatusName === 'OUT FOR DELIVERY' && nextStatusName === 'DELIVERED';

    if (isOperator && isHomeMilling && isFromNewToPicked) {
      alert('Action not allowed: Operators cannot move home-milling orders from NEW → PICKED UP.');
      return;
    }

    if (isOperator && isOutToDelivered) {
      alert('Action not allowed: Operators are not permitted to mark orders OUT FOR DELIVERY → DELIVERED.');
      return;
    }

    if (nextStatus?.status_name === "DELIVERED") {
      const radios = document.querySelectorAll(`input[name="payment_${orderId}"]`);
      let selected = null;
      radios.forEach(r => { if (r.checked) selected = r.value; });

      if (!selected) {
        const err = document.getElementById("paymentError");
        if (err) err.classList.remove("hidden");
        return;
      }

      await supabase.from('orders').update({ 
        status_id: newStatusId, 
        payment_status: selected,
        delivered_at: new Date().toISOString()
      }).eq('id', orderId);

      closeModal();
      await loadOrders();
      return;
    }

    await supabase.from('orders').update({ status_id: newStatusId }).eq('id', orderId);
    closeModal();
    await loadOrders();
  }
  window.updateOrderStatus = updateOrderStatus;

  async function savePaymentMethod(orderId, value) {
    await supabase.from('orders').update({ payment_status: value }).eq('id', orderId);
    await loadOrders();
  }
  window.savePaymentMethod = savePaymentMethod;

  async function loadFilterButtons() {
    await fetchStatuses();
    const filterGroup = document.querySelector('.filter-group');

    filterGroup.innerHTML = `<label class="font-medium">Filter by:</label>
      <button class="filter-btn active px-3 py-1 border rounded" data-value="all">All</button>`;

    statusesCache.forEach(s => {
      filterGroup.innerHTML += `
        <button class="filter-btn px-3 py-1 border rounded" data-value="${s.id}">
          ${s.status_name}
        </button>`;
    });

    document.querySelectorAll('.filter-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active', 'bg-blue-500', 'text-white'));
        btn.classList.add('active', 'bg-blue-500', 'text-white');
        loadOrders();
      });
    });
  }

  // ---------- NEW: Delivered totals logic ----------
  // Returns date range (local "today") as ISO strings
  function getTodayRangeISOs() {
    const now = new Date();
    // local midnight
    const start = new Date(now);
    start.setHours(0,0,0,0);
    const end = new Date(start);
    end.setDate(end.getDate() + 1);
    return { startISO: start.toISOString(), endISO: end.toISOString(), localStart: start, localEnd: end };
  }

  // Best-effort deliverer name resolver
 // Best-effort deliverer name resolver (updated to use delivered_by column)
async function resolveDelivererNames(orders) {
  // collect delivered_by ids
  const idList = Array.from(new Set(
    orders
      .map(o => o.delivered_by)
      .filter(v => v && typeof v === 'string')
  ));

  const usersById = {};
  if (idList.length > 0) {
    const { data: usersData, error: usersErr } = await supabase
      .from('users')
      .select('id, name')
      .in('id', idList);

    if (!usersErr && Array.isArray(usersData)) {
      usersData.forEach(u => {
        usersById[u.id] = u.name || null;
      });
    } else {
      console.warn('resolveDelivererNames: users fetch failed', usersErr);
    }
  }

  // map order id -> deliverer name (delivered_by_name override -> users table -> customer name -> placeholder)
  const map = {};
  orders.forEach(o => {
    let name = null;
    if (o.delivered_by_name && String(o.delivered_by_name).trim() !== '') {
      name = o.delivered_by_name;
    } else if (o.delivered_by && usersById[o.delivered_by]) {
      name = usersById[o.delivered_by];
    } else if (o.customers && o.customers.name) {
      name = `(customer) ${o.customers.name}`;
    }
    map[o.id] = name || '—';
  });

  return map;
}


  // Fetch today's delivered orders and compute totals, then render accordion
  async function fetchAndRenderDeliveredTotals() {
    // ensure statuses loaded
    if (!Array.isArray(statusesCache) || statusesCache.length === 0) await fetchStatuses();

    const { startISO, endISO } = getTodayRangeISOs();

    // fetch delivered orders delivered_at between start and end
    const { data, error } = await supabase
      .from('orders')
      .select(`id, token_number, total_price, payment_status, delivered_at, delivered_by, delivered_by_name, delivered_by_id, serve_at, status_backup, customers(name)`)
      .gte('delivered_at', startISO)
      .lt('delivered_at', endISO)
      .order('delivered_at', { ascending: false });

    if (error) {
      console.error('fetchAndRenderDeliveredTotals: error fetching delivered orders', error);
      document.getElementById('deliveredTotalsWrapper').innerHTML = '';
      return;
    }

    const deliveredOrders = data || [];

    // compute totals
    let totalCash = 0;
    let totalOnline = 0;
    deliveredOrders.forEach(o => {
      const amt = Number(o.total_price || 0);
      const ps = (o.payment_status || '').toString().toLowerCase();
      if (ps === 'cash') totalCash += amt;
      else if (ps === 'online') totalOnline += amt;
      // else ignore unknown
    });

    // resolve deliverer names
    const delivererMap = await resolveDelivererNames(deliveredOrders);

    // build HTML
    let rowsHtml = '';
    deliveredOrders.forEach(o => {
      const deliveredAtLocal = window.convertUTCToIST ? window.convertUTCToIST(o.delivered_at) : (o.delivered_at || '');
      const deliverer = delivererMap[o.id] || '—';
      rowsHtml += `<tr class="border-b">
        <td class="px-3 py-2 text-sm">${o.token_number || ''}</td>
        <td class="px-3 py-2 text-sm">₹${Number(o.total_price || 0).toFixed(2)}</td>
        <td class="px-3 py-2 text-sm">${o.payment_status || '—'}</td>
        <td class="px-3 py-2 text-sm">${deliveredAtLocal}</td>
        <td class="px-3 py-2 text-sm">${deliverer}</td>
      </tr>`;
    });

    const wrapper = document.getElementById('deliveredTotalsWrapper');
    wrapper.innerHTML = `
      <details class="border rounded p-3 bg-gray-50">
        <summary class="font-medium cursor-pointer">Today's delivered summary (click to expand)</summary>
        <div class="mt-3 grid grid-cols-1 md:grid-cols-3 gap-3">
          <div class="p-3 bg-white rounded shadow">
            <div class="text-sm text-gray-500">Total Cash (Delivered today)</div>
            <div class="text-xl font-semibold mt-1">₹${totalCash.toFixed(2)}</div>
          </div>
          <div class="p-3 bg-white rounded shadow">
            <div class="text-sm text-gray-500">Total Online (Delivered today)</div>
            <div class="text-xl font-semibold mt-1">₹${totalOnline.toFixed(2)}</div>
          </div>
          <div class="p-3 bg-white rounded shadow">
            <div class="text-sm text-gray-500">Delivered Orders</div>
            <div class="text-lg font-semibold mt-1">${deliveredOrders.length}</div>
          </div>
        </div>

        <div class="mt-4 overflow-x-auto">
          <table class="min-w-full bg-white rounded">
            <thead class="bg-gray-100">
              <tr>
                <th class="text-left px-3 py-2 text-xs">Token</th>
                <th class="text-left px-3 py-2 text-xs">Total</th>
                <th class="text-left px-3 py-2 text-xs">Payment</th>
                <th class="text-left px-3 py-2 text-xs">Delivered At</th>
                <th class="text-left px-3 py-2 text-xs">Delivered By</th>
              </tr>
            </thead>
            <tbody>
              ${rowsHtml || `<tr><td class="px-3 py-2 text-sm" colspan="5">No deliveries today</td></tr>`}
            </tbody>
          </table>
        </div>
      </details>
    `;
  }

  // Expose for debugging if needed
  window.fetchAndRenderDeliveredTotals = fetchAndRenderDeliveredTotals;
  // ---------- END NEW delivered totals logic ----------

  async function loadOrders() {
    const allOrders = await fetchAllOrders();
    // refresh delivered totals first so numbers show alongside filtered UI
    await fetchAndRenderDeliveredTotals();

    const activeFilterEl = document.querySelector('.filter-btn.active');
    const activeFilter = activeFilterEl ? activeFilterEl.dataset.value : 'all';
    const searchTerm = (document.getElementById('searchBox').value || '').toLowerCase();

    let filtered = allOrders;
    if (activeFilter !== 'all') {
      filtered = filtered.filter(o => String(o.status_id) === String(activeFilter));
    }

    if (searchTerm.trim() !== '') {
      filtered = filtered.filter(o => {
        const statusObj = statusesCache.find(s => s.id === o.status_id);
        const statusName = statusObj?.status_name?.toLowerCase() || '';
        return (
          (o.customers?.name?.toLowerCase() || '').includes(searchTerm) ||
          (String(o.customers?.phone_number || '')).includes(searchTerm) ||
          (String(o.token_number || '').toLowerCase()).includes(searchTerm) ||
          (String(o.total_price || '')).includes(searchTerm) ||
          statusName.includes(searchTerm) ||
          (Array.isArray(o.grain_details) && o.grain_details.some(g =>
            (g.grain?.toLowerCase() || '').includes(searchTerm)))
        );
      });
    }

    const container = document.getElementById('ordersList');
    container.innerHTML = '';

    if (filtered.length === 0) {
      container.innerHTML = '<p class="text-gray-500">No orders found...</p>';
      return;
    }

    filtered.forEach(order => {
      const grainsHTML = Array.isArray(order.grain_details)
        ? '<ul class="list-disc ml-6 text-sm text-gray-600">' +
          order.grain_details.map(g => `<li>${g.grain} - ${g.quantity} kg</li>`).join('') +
          '</ul>' : '';

      const statusObj = statusesCache.find(s => s.id === order.status_id);
      const statusLabel = statusObj ? statusObj.status_name : "Unknown";
      const statusClass = getStatusClass(statusLabel);

      let paymentText = "Not Paid";
      let paymentClass = "text-gray-500";
      if (order.payment_status === "online" || order.payment_status === "cash") {
        paymentText = order.payment_status;
        paymentClass = "text-green-600";
      }

      const millingPref = order.customers?.milling_preference || "No Preference";

      const div = document.createElement('div');
      div.className = 'order-card bg-white shadow rounded-lg p-4 cursor-pointer hover:ring-2 hover:ring-blue-400';
      div.innerHTML = `
        <div class="flex justify-between items-center mb-2">
          <div class="flex items-center gap-2">${getOrderTypeIcon(order.order_type)}</div>
          <div class="text-sm text-gray-600"><strong>Token:</strong> ${order.token_number || ''}</div>
        </div>
        <h3 class="font-semibold text-lg">${order.customers?.name || 'N/A'}</h3>
        <p><strong>Phone:</strong> <a href="tel:${order.customers?.phone_number || ''}" class="text-blue-600 underline">${order.customers?.phone_number || 'N/A'}</a></p>
        <p><strong>Created:</strong> ${window.convertUTCToIST ? window.convertUTCToIST(order.created_at) : order.created_at}</p>
        <p class="mt-4 text-lg"><strong>Total:</strong> ₹${(order.total_price || 0).toFixed(2)}</p>
        ${grainsHTML ? `<div class="mt-2"><strong>Grains <span class="text-xs text-gray-600">(${millingPref})</span>:</strong>${grainsHTML}</div>` : ''}
        <div class="mt-2 flex justify-between items-center">
          <span><strong>Status:</strong> <span class="px-2 py-1 text-xs rounded ${statusClass}">${statusLabel}</span></span>
          <span class="text-xs ${paymentClass}">${paymentText}</span>
        </div>
      `;

      div.addEventListener('click', () => openModal(order));
      container.appendChild(div);
    });
  }

  function nameIncludesKeyword(name, keyword) {
    if (!name) return false;
    return String(name).toUpperCase().replace(/[-_]/g,' ').includes(keyword.toUpperCase());
  }

async function openModal(order) {
  const modal = document.getElementById("orderModal");
  const content = document.getElementById("modalContent");

  currentOpenOrder = order;

  const grainsHTML = Array.isArray(order.grain_details)
    ? '<ul class="list-disc ml-6 text-sm text-gray-600">' +
      order.grain_details.map(g => `<li>${g.grain} - ${g.quantity} kg</li>`).join('') +
      '</ul>' : '';

  const statusObj = statusesCache.find(s => s.id === order.status_id);
  const statusLabel = statusObj ? statusObj.status_name : "Unknown";
  const statusClass = getStatusClass(statusLabel);
  const next = getNextStatus(order);

  content.innerHTML = `
    <div class="flex justify-between items-center mb-2">
      <div class="flex items-center gap-2">${getOrderTypeIcon(order.order_type)}</div>
      <div class="text-sm text-gray-600"><strong>Token:</strong> ${order.token_number || ''}</div>
    </div>

    <div class="mb-2">
      <h2 class="text-xl font-bold mb-1">${order.customers?.name || 'N/A'}</h2>
      <p class="text-sm text-gray-500 mb-1">${order.customers?.phone_number ? `<a href="tel:${order.customers?.phone_number}" class="text-blue-600 underline">${order.customers?.phone_number}</a>` : 'N/A'}</p>
      <div class="text-sm text-gray-600"><strong>Created:</strong> ${window.convertUTCToIST ? window.convertUTCToIST(order.created_at) : order.created_at}</div>
    </div>

    <p class="mt-4 text-lg"><strong>Total:</strong> ₹${(order.total_price || 0).toFixed(2)}</p>

    ${grainsHTML}
    <p class="mt-2"><strong>Status:</strong> <span class="px-2 py-1 text-xs rounded ${statusClass}">${statusLabel}</span></p>
    <div id="modalActions"></div>
  `;
  modal.classList.remove("hidden");

  let role = null;
  try {
    role = await fetchUserRole();
  } catch (e) {
    console.warn('openModal: fetchUserRole failed', e);
  }

  const actionsContainer = document.getElementById('modalActions');
  actionsContainer.innerHTML = '';

  if (!next) {
    return;
  }

  const orderTypeNorm = (order?.order_type || '').toString().toLowerCase();
  const curName = (statusLabel || '').toString().trim().toUpperCase();
  const nextName = (next?.status_name || '').toString().trim().toUpperCase();

  const isHomeMilling = orderTypeNorm.includes('home') && orderTypeNorm.includes('mill');
  const isOperator = String(role||'').toLowerCase() === 'operator';
  const isNewToPicked = curName === 'NEW' && nextName === 'PICKED UP';
  const isOutToDelivered = curName === 'OUT FOR DELIVERY' && nextName === 'DELIVERED';

  const blockedTransition = (isOperator && isHomeMilling && isNewToPicked) || (isOperator && isOutToDelivered);

  if (nameIncludesKeyword(next.status_name, "DELIVERED")) {
    const disabledAttr = blockedTransition ? 'disabled aria-disabled="true" title="Operators cannot mark Out For Delivery → Delivered"' : '';
    const onchangeAttr = blockedTransition ? '' : `onchange="savePaymentMethod('${order.id}', this.value); document.getElementById('paymentError')?.classList.add('hidden');"`;

    actionsContainer.innerHTML += `
      <div class="mt-4">
        <p class="font-medium mb-2">Payment Method:</p>
        <label class="flex items-center gap-2 py-2">
          <input type="radio" name="payment_${order.id}" value="online"
            ${order.payment_status === 'online' ? 'checked' : ''} ${disabledAttr}
            ${onchangeAttr} /> Paid Online
        </label>
        <label class="flex items-center gap-2 py-2">
          <input type="radio" name="payment_${order.id}" value="cash"
            ${order.payment_status === 'cash' ? 'checked' : ''} ${disabledAttr}
            ${onchangeAttr} /> Paid Cash
        </label>
        <p id="paymentError" class="text-red-600 text-sm mt-2 ${blockedTransition ? '' : 'hidden'}">${blockedTransition ? '⚠ Payment selection disabled for your role.' : '⚠ Please select a payment method before marking as Delivered.'}</p>
      </div>
    `;
  }

  if (blockedTransition) {
    const titleText = isOperator && isOutToDelivered
      ? 'Operators cannot mark Out For Delivery → Delivered.'
      : 'Operators are not permitted to perform this transition.';
    actionsContainer.innerHTML += `
      <button
        class="mt-4 w-full bg-blue-500 text-white py-2 rounded opacity-50 cursor-not-allowed"
        aria-disabled="true"
        title="${titleText}"
        onclick="(function(){ alert('Action blocked: You do not have permission to perform this transition.'); })()"
      >
        Move to ${next.status_name}
      </button>
    `;
  } else {
    actionsContainer.innerHTML += `
      <button onclick="updateOrderStatus('${order.id}', '${next.id}')" 
        class="mt-4 w-full bg-blue-500 text-white py-2 rounded hover:bg-blue-600">
        Move to ${next.status_name}
      </button>
    `;
  }
}
  window.openModal = openModal;

  function closeModal() { 
    document.getElementById("orderModal").classList.add("hidden"); 
    currentOpenOrder = null;
  }
  window.closeModal = closeModal;

  function debouncedSearch() {
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => loadOrders(), 300);
  }
  window.debouncedSearch = debouncedSearch;

  function handleSearchInput() {
    const searchBox = document.getElementById('searchBox');
    const searchBtn = document.getElementById('searchBtn');
    searchBtn.disabled = searchBox.value.trim() === '';
    debouncedSearch();
  }
  window.handleSearchInput = handleSearchInput;

  async function searchAndScroll() {
    const searchBox = document.getElementById('searchBox');
    if (searchBox.value.trim() === '') return;
    await loadOrders();
    
    const container = document.getElementById('ordersList');
    const firstOrder = container.querySelector('.order-card');
    if (firstOrder) {
      firstOrder.scrollIntoView({ behavior: 'smooth', block: 'center' });
      firstOrder.classList.add("ring-2", "ring-blue-400");
      setTimeout(() => firstOrder.classList.remove("ring-2", "ring-blue-400"), 2000);
    }
  }
  window.searchAndScroll = searchAndScroll;

  function resetSearch() {
    document.getElementById('searchBox').value = '';
    document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active','bg-blue-500','text-white'));
    document.querySelector('.filter-btn[data-value="all"]').classList.add('active','bg-blue-500','text-white');
    loadOrders();
  }
  window.resetSearch = resetSearch;

  await initializeFlows();
  await loadFilterButtons();
  await loadOrders();
  // ---------- End business logic ----------
})();
</script>
</body>
</html>

