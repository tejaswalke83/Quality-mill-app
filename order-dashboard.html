<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Order Dashboard</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
    }

    h1 {
      text-align: center;
      margin-bottom: 20px;
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 20px;
    }

    .search-group, .filter-group {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 10px;
    }

    .card {
      border: 1px solid #ccc;
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 12px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }

    .card h3 {
      margin: 0 0 10px;
    }

    button {
      padding: 8px 12px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    button:disabled {
      background-color: gray;
    }
    .filter-btn {
    border: 1px solid #ccc;
    padding: 6px 12px;
    border-radius: 6px;
    cursor: pointer;
    background-color: #f9f9f9;
    font-size: 14px;
  }
  .filter-btn.active {
    background-color: #007bff;
    color: #fff;
    border-color: #007bff;
  }
  .card-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 8px;
  }
  .card-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 12px;
  }
  </style>
</head>
<body>
  <h1>Order Dashboard</h1>

  <div class="controls">
   <div class="search-group">
  <input 
    type="text" 
    id="searchBox" 
    placeholder="Search by name, phone, token, total, status, grain..." 
    oninput="debouncedSearch()" 
  />
  <button onclick="resetSearch()">Reset</button>
</div>



    <div class="filter-group">
      <label><strong>Filter by:</strong></label>
      <label><input type="radio" name="status" value="all" checked onchange="loadOrders()"> All</label>
      <label><input type="radio" name="status" value="new" onchange="loadOrders()"> New</label>
      <label><input type="radio" name="status" value="in_progress" onchange="loadOrders()"> In Progress</label>
      <label><input type="radio" name="status" value="milling_completed" onchange="loadOrders()"> Milling Completed</label>
      <label><input type="radio" name="status" value="delivered" onchange="loadOrders()"> Delivered</label>
    </div>
  </div>

  <div id="ordersList"></div>
<script src="script.js"></script>
<script type="module">
  window.updateOrderStatus = updateOrderStatus;

import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm';

 const supabaseUrl = 'https://odczzymxgjsjhbufffxm.supabase.co';
    const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9kY3p6eW14Z2pzamhidWZmZnhtIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQzMjY2NDIsImV4cCI6MjA2OTkwMjY0Mn0.T2ZT6U11taDH7vNTUJgI9xvqEZ1YEfBrNx28QV7jJvI';
    const supabase = createClient(supabaseUrl, supabaseKey);

let searchTimeout;
function debouncedSearch() {
  clearTimeout(searchTimeout);
  searchTimeout = setTimeout(() => {
    loadOrders();
  }, 300); // 300ms debounce
}


async function fetchAllOrders() {
  const { data, error } = await supabase
  .from('orders')
  .select(`
    *,
    customers(name, phone_number),
    order_statuses(status_name, sort_order, id)
  `)
  .order('created_at', { ascending: false });

  if (error) {
    console.error('Error fetching orders:', error);
    return [];
  }

  return data;
}



// Define status flows
async function buildStatusFlows() {
  const { data: statuses, error } = await supabase
    .from('order_statuses')
    .select('*')
    .order('sort_order', { ascending: true });

  if (error) {
    console.error('Error fetching statuses:', error);
    return {};
  }

  statusesCache = statuses;

  // Build flows for each order_type automatically
  // Example mapping for different order types
  const flows = {
    "shop-milling": statuses.map(s => s.id),      // all statuses in order
    "shop-buy-mill": statuses.map(s => s.id),     // customize if needed
    "home-milling": statuses.map(s => s.id),
    "home-buy-mill": statuses.map(s => s.id)
  };

  return flows;
}


// const statusFlows = {
//   shop_milling:    [1, 4, 5, 7],
//   shop_buy_mill:   [1, 4, 5, 7],
//   home_milling:    [1, 2, 3, 4, 5, 6, 7],
//   home_buy_mill:   [1, 2, 3, 4, 5, 6, 7]
// };

let statusesCache = []; // cache statuses for labels

async function fetchStatuses() {
  const { data, error } = await supabase
    .from('order_statuses')
    .select('*')
    .order('sort_order', { ascending: true });

  if (error) {
    console.error('Error fetching statuses:', error);
    return [];
  }
  statusesCache = data;
  return data;
}

// Get next status id for this order
let statusFlows = {}; // will be filled dynamically

async function initializeFlows() {
  statusFlows = await buildStatusFlows();
}

function getNextStatus(order) {
  const flow = statusFlows[order.order_type] || [];

  // âœ… Use the actual status_id from the order
  const currentStatusId = order.status_id;
  if (!currentStatusId) return null;

  const idx = flow.indexOf(currentStatusId);
  if (idx === -1 || idx + 1 >= flow.length) return null;

  const nextId = flow[idx + 1];
  // âœ… Find the next status object in cache
  return statusesCache.find(s => s.id === nextId);
}

// function getNextStatus(order) {
//   const flow = statusFlows[order.order_type] || [];

//   const currentStatusId = order.order_statuses?.id;
//   if (!currentStatusId) return null;

//   const idx = flow.indexOf(currentStatusId);
//   if (idx === -1 || idx + 1 >= flow.length) return null;

//   const nextId = flow[idx + 1];
//   return statusesCache.find(s => s.id === nextId);
// }

// function getNextStatus(order) {
//   const flow = statusFlows[order.order_type] || [];
//   console.log("----flow-order type--->", order.order_type, flow);

//   // Ensure order_statuses exists
//   if (!order.order_statuses) {
//     console.warn("Order has no order_statuses:", order.id);
//     return null;
//   }

//   const currentStatusId = order.order_statuses.id;
//   console.log("----currentStatusId--->", currentStatusId);

//   // Find current index in the flow
//   const idx = flow.indexOf(currentStatusId);
//   if (idx === -1) {
//     console.warn("Current status not in flow:", currentStatusId);
//     return null;
//   }
//   if (idx + 1 >= flow.length) return null;

//   const nextId = flow[idx + 1];
//   const nextStatus = statusesCache.find(s => s.id === nextId);

//   console.log("----nextStatus--->", nextStatus);
//   return nextStatus || null;
// }


// function getNextStatus(order) {
//   const flow = statusFlows[order.order_type] || [];

//    console.log("----flow-order type---> "+flow);
  
//   // Get current status id from the joined order_statuses object
//   const currentStatusId = order.order_statuses?.id;
//   console.log("----currentStatusId---> "+currentStatusId);
//   if (!currentStatusId) return null;

//   // Find the index of current status in the flow
//   const idx = flow.indexOf(currentStatusId);
//   if (idx === -1 || idx + 1 >= flow.length) return null;

//   const nextId = flow[idx + 1];
//   // Find the next status object from statusesCache
//   return statusesCache.find(s => s.id === nextId);
// }

await initializeFlows();
loadOrders();


async function updateOrderStatus(orderId, newStatusId) {
  const { error } = await supabase
    .from('orders')
    .update({ status_id: newStatusId }) // âœ… use status_id
    .eq('id', orderId);

  if (error) {
    alert('Failed to update status');
    console.error(error);
  } else {
    loadOrders(); // reload orders after update
  }
}



async function loadFilterButtons() {
  const statuses = await fetchStatuses();
  const filterGroup = document.querySelector('.filter-group');
  filterGroup.innerHTML = `<label><strong>Filter by:</strong></label>
    <button class="filter-btn active" data-value="all">All</button>`;

  statuses.forEach(s => {
    filterGroup.innerHTML += `
      <button class="filter-btn" data-value="${s.status_name}">${s.status_name}</button>
    `;
  });

  document.querySelectorAll('.filter-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      loadOrders();
    });
  });
} 

async function loadOrders() {
  const allOrders = await fetchAllOrders();

  // Get active filter
  const activeFilterEl = document.querySelector('.filter-btn.active');
  const activeFilter = activeFilterEl ? activeFilterEl.dataset.value : 'all';

  const searchTerm = document.getElementById('searchBox').value.toLowerCase();

  let filtered = allOrders;

  // ðŸ”¹ Filter by status (using joined order_statuses)
  if (activeFilter !== 'all') {
    filtered = filtered.filter(o => 
      o.order_statuses?.status_name === activeFilter
    );
  }

  // ðŸ”¹ Search across multiple fields
  if (searchTerm.trim() !== '') {
    filtered = filtered.filter(o =>
      (o.customers?.name?.toLowerCase() || '').includes(searchTerm) ||
      (o.customers?.phone_number || '').includes(searchTerm) ||
      (o.token_number?.toLowerCase() || '').includes(searchTerm) ||
      (o.total_price?.toString() || '').includes(searchTerm) ||
      (o.order_statuses?.status_name?.toLowerCase() || '').includes(searchTerm) ||
      (Array.isArray(o.grain_details) &&
        o.grain_details.some(g =>
          (g.grain?.toLowerCase() || '').includes(searchTerm)
        ))
    );
  }

  const container = document.getElementById('ordersList');
  container.innerHTML = '';

  if (filtered.length === 0) {
    container.innerHTML = '<p>No orders found.</p>';
    return;
  }

  // ðŸ”¹ Render each order
  filtered.forEach(order => {
    let grainsHTML = '';
    const totalPrice = order.total_price || 0;

    if (order.grain_details && Array.isArray(order.grain_details)) {
      grainsHTML = '<ul>' + order.grain_details.map(g =>
        `<li>${g.grain} - ${g.quantity} kg</li>`
      ).join('') + '</ul>';
    }

    const statusLabel = order.order_statuses?.status_name || "Unknown";
    const next = getNextStatus(order); // âœ… get next status from flow

    const div = document.createElement('div');
    div.className = 'card';
    div.innerHTML = `
      <div class="card-header">
        <h3>${order.customers?.name || 'N/A'}</h3>
        <div style="text-align:right">
          <strong>Token:</strong> ${order.token_number || ''}<br>
          <strong>Total:</strong> â‚¹${totalPrice.toFixed(2)}
        </div>
      </div>
      <p><strong>Phone:</strong> ${order.customers?.phone_number || 'N/A'}</p>
      <p><strong>Created:</strong> ${window.convertUTCToIST(order.created_at)}</p>
      ${grainsHTML ? `<p><strong>Grains:</strong>${grainsHTML}</p>` : ''}
      <div class="card-footer">
        <span><strong>Status:</strong> ${statusLabel}</span>
       ${next 
  ? `<button onclick="updateOrderStatus('${order.id}', '${next.id}')">
       Move to ${next.status_name}
     </button>` 
  : ''
}

      </div>
    `;

    container.appendChild(div);
  });
}



function resetSearch() {
  document.getElementById('searchBox').value = '';
  loadOrders();
}
window.debouncedSearch = debouncedSearch;
window.loadOrders = loadOrders;
window.resetSearch = resetSearch;

loadFilterButtons();
loadOrders();
</script>

  
</body>
</html>
