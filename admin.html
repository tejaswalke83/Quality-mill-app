<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Admin Panel</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Visual tweaks */
    .status-badge { display:inline-block; padding:4px 8px; border-radius:9999px; font-size:12px; font-weight:600; }
    .status-name { font-size:12px; color:#374151; }         /* smaller status label */
    .status-count { font-size:28px; font-weight:800; }      /* bigger, bold numbers */
    .status-card { transition: box-shadow .18s ease, transform .12s ease; }
    .status-card:hover { transform: translateY(-4px); box-shadow: 0 8px 28px rgba(15,23,42,0.08); }

    /* Pulse animation for NEW card */
    @keyframes pulseBadge {
      0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(250, 204, 21, 0.0); }
      40% { transform: scale(1.06); box-shadow: 0 0 0 8px rgba(250, 204, 21, 0.12); }
      100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(250, 204, 21, 0.0); }
    }
    .pulse {
      animation: pulseBadge 1.6s ease-in-out 1;
    }

    /* Layout: ensure refresh controls at extreme right */
    .status-header { display:flex; align-items:center; justify-content:space-between; gap:12px; }
    .status-controls { display:flex; align-items:center; gap:12px; margin-left:auto; }

    /* card grid arrangement enforcing 4 columns visual grouping */
    .status-grid { display:grid; gap:16px; grid-template-columns: repeat(4, minmax(0,1fr)); }

    /* smaller timestamp */
    .refresh-meta { font-size: 13px; color: #6b7280; }

    /* remove the small "click to filter" copy — not needed */
    .status-card .subtext { display: none; }

    /* responsive tweaks: 2 cols under small screens */
    @media (max-width: 768px) {
      .status-grid { grid-template-columns: repeat(2, minmax(0,1fr)); }
    }

    /* Toast */
    #admin-toast { transition: opacity .2s ease; }

  </style>
</head>
<body class="h-screen flex bg-gray-100">

  <!-- Sidebar -->
  <aside class="w-64 bg-white shadow-md">
    <div class="p-4 text-xl font-bold border-b">Admin Panel</div>
    <nav class="mt-4">
      <ul>
        <li><button onclick="showSection('dashboard')" class="w-full text-left px-4 py-2 hover:bg-gray-200">Dashboard</button></li>
        <li><button onclick="showSection('config')" class="w-full text-left px-4 py-2 hover:bg-gray-200">Configurations</button></li>
        <li><button onclick="showSection('users')" class="w-full text-left px-4 py-2 hover:bg-gray-200">Users</button></li>
        <li><button onclick="showSection('societies')" class="w-full text-left px-4 py-2 hover:bg-gray-200">Societies</button></li>
        <li><button onclick="showSection('orders')" class="w-full text-left px-4 py-2 hover:bg-gray-200">Orders</button></li>
        <li><button onclick="showSection('grains')" class="w-full text-left px-4 py-2 hover:bg-gray-200">Grains</button></li>
      </ul>
    </nav>
  </aside>

  <!-- Main Content -->
  <main class="flex-1 p-6 overflow-y-auto">

    <!-- Dashboard Section -->
    <section id="section-dashboard">
      <h1 class="text-2xl font-bold mb-6">Dashboard Overview</h1>

      <!-- Top counts -->
      <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6 mb-6">
        <div class="bg-white p-6 rounded-lg shadow cursor-pointer" onclick="showSection('users')">
          <h2 class="text-gray-600">Total Users</h2>
          <p id="card-users" class="text-3xl font-bold mt-2">0</p>
        </div>
        <div class="bg-white p-6 rounded-lg shadow cursor-pointer" onclick="showSection('societies')">
          <h2 class="text-gray-600">Total Societies</h2>
          <p id="card-societies" class="text-3xl font-bold mt-2">0</p>
        </div>
        <div class="bg-white p-6 rounded-lg shadow cursor-pointer" onclick="showSection('orders')">
          <h2 class="text-gray-600">Total Orders</h2>
          <p id="card-orders" class="text-3xl font-bold mt-2">0</p>
        </div>
        <div class="bg-white p-6 rounded-lg shadow cursor-pointer" onclick="showSection('grains')">
          <h2 class="text-gray-600">Total Grains</h2>
          <p id="card-grains" class="text-3xl font-bold mt-2">0</p>
        </div>
        <div class="bg-white p-6 rounded-lg shadow cursor-pointer" onclick="showSection('config')">
          <h2 class="text-gray-600">Active Configs</h2>
          <p id="card-configs" class="text-3xl font-bold mt-2">0</p>
        </div>
      </div>

      <!-- Status header with Refresh controls (Refresh on far right) -->
      <div class="flex items-center justify-between mb-3">
        <h2 class="text-lg font-semibold">Orders by Status</h2>

        <div style="margin-left:auto; display:flex; align-items:center; gap:12px;">
          <div id="last-refresh" class="refresh-meta">Last refreshed: —</div>
          <button id="refresh-now-btn" onclick="manualRefresh()" class="px-3 py-1 bg-indigo-600 text-white rounded hover:bg-indigo-700">Refresh Now</button>
          <button id="archive-btn" onclick="archiveOldDeliveredOrders()" class="px-3 py-1 bg-gray-800 text-white rounded hover:bg-gray-900">Archive Orders</button>
        </div>
      </div>

      <!-- Status Cards grid -->
      <!-- We'll render them into #status-cards in the order you requested -->
      <div id="status-cards" class="status-grid mb-6">
        <!-- injected by JS -->
      </div>

    </section>

    <!-- Configurations -->
    <section id="section-config" class="hidden">
      <h1 class="text-2xl font-bold mb-4">Configuration Management</h1>
      <button onclick="openForm()" class="mb-4 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">+ Add Configuration</button>
      <table class="w-full border-collapse border border-gray-300">
        <thead class="bg-gray-200"><tr>
          <th class="border p-2">ID</th><th class="border p-2">Key</th>
          <th class="border p-2">Value</th><th class="border p-2">Description</th>
          <th class="border p-2">Actions</th>
        </tr></thead>
        <tbody id="configTable" class="text-center"></tbody>
      </table>
    </section>

    <!-- Orders -->
    <section id="section-orders" class="hidden">
      <h1 class="text-2xl font-bold mb-4">Order Management</h1>
      <div class="mb-4">
        <button onclick="fetchOrders()" class="mr-2 px-3 py-1 border rounded">Show All</button>
        <span id="orders-filter-label" class="text-sm text-gray-600"></span>
      </div>
      <table class="w-full border-collapse border border-gray-300">
        <thead class="bg-gray-200"><tr>
          <th class="border p-2">ID</th><th class="border p-2">Customer ID</th>
          <th class="border p-2">Grain</th><th class="border p-2">Quantity (kg)</th>
          <th class="border p-2">Price</th><th class="border p-2">Order Type</th>
          <th class="border p-2">Payment</th><th class="border p-2">Status</th>
          <th class="border p-2">Created</th><th class="border p-2">Actions</th>
        </tr></thead>
        <tbody id="ordersTable" class="text-center"></tbody>
      </table>
    </section>

    <!-- Users -->
    <section id="section-users" class="hidden">
      <h1 class="text-2xl font-bold mb-4">User Management</h1>
      <p class="text-gray-600">Coming soon...</p>
    </section>

    <!-- Societies -->
    <section id="section-societies" class="hidden">
      <h1 class="text-2xl font-bold mb-4">Society Management</h1>
      <button onclick="openSocietyForm()" class="mb-4 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">+ Add Society</button>
      <table class="w-full border-collapse border border-gray-300">
        <thead class="bg-gray-200"><tr>
          <th class="border p-2">ID</th><th class="border p-2">Name</th>
          <th class="border p-2">Address</th><th class="border p-2">Contact</th>
          <th class="border p-2">Active</th><th class="border p-2">Actions</th>
        </tr></thead>
        <tbody id="societyTable" class="text-center"></tbody>
      </table>
    </section>

    <!-- Grains -->
    <section id="section-grains" class="hidden">
      <h1 class="text-2xl font-bold mb-4">Grain for Sell Management</h1>
      <button onclick="openGrainForm()" class="mb-4 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">+ Add Grain for Sell</button>
      <table class="w-full border-collapse border border-gray-300">
        <thead class="bg-gray-200"><tr>
          <th class="border p-2">ID</th><th class="border p-2">Product Name</th>
          <th class="border p-2">Grain</th><th class="border p-2">Price/kg</th>
          <th class="border p-2">Milling Price/kg</th><th class="border p-2">Stock Qty (kg)</th>
          <th class="border p-2">Active</th><th class="border p-2">Actions</th>
        </tr></thead>
        <tbody id="grainTable" class="text-center"></tbody>
      </table>
    </section>
  </main>

  <!-- Modals (config / society / grain) unchanged from your original - keep them here if you have them -->
  <!-- ... keep your modal HTML here (same as earlier file) ... -->

  <!-- Toast -->
  <div id="admin-toast" class="hidden fixed bottom-6 right-6 bg-black text-white text-sm px-4 py-2 rounded shadow-lg z-50"></div>

  <!-- Environment config -->
  <script src="config.js"></script>
  <!-- Supabase -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <!-- Main Script -->
  <script>
  const SUPABASE_URL = window._env_.SUPABASE_URL;
  const SUPABASE_KEY = window._env_.SUPABASE_ANON_KEY;
  const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

  let configs = [], societies = [], grains = [];
  let editId = null, editSocietyId = null, editGrainId = null;

  function showSection(name){
    document.querySelectorAll("main section").forEach(s=>s.classList.add("hidden"));
    document.getElementById("section-"+name).classList.remove("hidden");
    if(name==="config")fetchConfigs();
    if(name==="societies")fetchSocieties();
    if(name==="orders")fetchOrders();
    if(name==="grains")fetchGrains();
  }

  showSection('dashboard');

  // ---------- helper & existing functions (fetchConfigs, fetchSocieties, fetchGrains, etc.) ----------
  async function fetchConfigs(){
    const {data,error}=await supabase.from('Configuration').select('*').order('id');
    if(error)return console.error(error);
    configs=data;
    const t=document.getElementById("configTable");
    t.innerHTML=data.map(c=>`
      <tr>
        <td class="border p-2">${c.id}</td>
        <td class="border p-2">${c.config_key}</td>
        <td class="border p-2">${c.config_value}</td>
        <td class="border p-2">${c.description||'-'}</td>
        <td class="border p-2">
          <button onclick="editConfig(${c.id})" class="px-2 py-1 bg-yellow-500 text-white rounded">Edit</button>
          <button onclick="deleteConfig(${c.id})" class="px-2 py-1 bg-red-600 text-white rounded">Delete</button>
        </td></tr>`).join('');
    document.getElementById("card-configs").innerText=data.length;
  }
  function openForm(){document.getElementById("configFormModal").classList.remove("hidden")}
  function closeForm(){document.getElementById("configFormModal").classList.add("hidden")}
  async function saveConfig(){
    const key=configKey.value.trim(),val=configValue.value.trim(),desc=configDesc.value.trim();
    if(editId)await supabase.from('Configuration').update({config_key:key,config_value:val,description:desc}).eq('id',editId);
    else await supabase.from('Configuration').insert([{config_key:key,config_value:val,description:desc}]);
    closeForm();fetchConfigs(); refreshDashboardCountsAndStatuses();
  }
  function editConfig(id){const c=configs.find(x=>x.id===id);editId=id;openForm();configKey.value=c.config_key;configValue.value=c.config_value;configDesc.value=c.description||""}
  async function deleteConfig(id){await supabase.from('Configuration').delete().eq('id',id);fetchConfigs(); refreshDashboardCountsAndStatuses();}

  // ---------- SOCIETIES ----------
  async function fetchSocieties(){
    const {data,error}=await supabase.from('societies').select('*').order('created_at',{ascending:false});
    if(error)return console.error(error);
    societies=data;
    document.getElementById("societyTable").innerHTML=data.map(s=>`
      <tr>
        <td class="border p-2">${s.id}</td><td class="border p-2">${s.name}</td>
        <td class="border p-2">${s.address||'-'}</td><td class="border p-2">${s.contact_number||'-'}</td>
        <td class="border p-2">${s.is_active?'✅':'❌'}</td>
        <td class="border p-2">
          <button onclick="editSociety(${s.id})" class="px-2 py-1 bg-yellow-500 text-white rounded">Edit</button>
          <button onclick="deleteSociety(${s.id})" class="px-2 py-1 bg-red-600 text-white rounded">Delete</button>
        </td></tr>`).join('');
    document.getElementById("card-societies").innerText=data.length;
  }
  function openSocietyForm(){document.getElementById("societyFormModal").classList.remove("hidden")}
  function closeSocietyForm(){document.getElementById("societyFormModal").classList.add("hidden")}
  async function saveSociety(){
    const n=societyName.value.trim(),a=societyAddress.value.trim(),c=societyContact.value.trim();
    if(editSocietyId)await supabase.from('societies').update({name:n,address:a,contact_number:c}).eq('id',editSocietyId);
    else await supabase.from('societies').insert([{name:n,address:a,contact_number:c}]);
    closeSocietyForm();fetchSocieties(); refreshDashboardCountsAndStatuses();
  }
  function editSociety(id){const s=societies.find(x=>x.id===id);editSocietyId=id;openSocietyForm();societyName.value=s.name;societyAddress.value=s.address||"";societyContact.value=s.contact_number||""}
  async function deleteSociety(id){await supabase.from('societies').delete().eq('id',id);fetchSocieties(); refreshDashboardCountsAndStatuses();}

  // ---------- ORDERS ----------
  // fetchOrders optionally filters by statusId
  async function fetchOrders(statusId = null){
    const filterLabel = document.getElementById('orders-filter-label');
    if(statusId) {
      const { data: st } = await supabase.from('order_statuses').select('status_name').eq('id', statusId).maybeSingle();
      filterLabel.innerText = st ? `Filtered: ${st.status_name}` : '';
    } else {
      filterLabel.innerText = '';
    }

    let query = supabase.from('orders').select('*').order('created_at',{ascending:false}).limit(200);
    if(statusId) query = query.eq('status_id', statusId);

    const {data,error} = await query;
    if(error) return console.error(error);

    document.getElementById("ordersTable").innerHTML=data.map(o=>`
      <tr><td class="border p-2">${o.id}</td><td class="border p-2">${o.customer_id||'-'}</td>
      <td class="border p-2">${o.grain_type||'-'}</td><td class="border p-2">${o.quantity_kg||'-'}</td>
      <td class="border p-2">${o.total_price||'-'}</td><td class="border p-2">${o.order_type||'-'}</td>
      <td class="border p-2">${o.payment_status||'-'}</td><td class="border p-2">${o.status_backup||'-'}</td>
      <td class="border p-2">${o.created_at?new Date(o.created_at).toLocaleString():'-'}</td>
      <td class="border p-2"><button onclick="deleteOrder(${o.id})" class="px-2 py-1 bg-red-600 text-white rounded">Delete</button></td></tr>`).join('');
    document.getElementById("card-orders").innerText = data.length;
  }
  async function deleteOrder(id){await supabase.from('orders').delete().eq('id',id);fetchOrders(); refreshDashboardCountsAndStatuses();}

  // ---------- GRAINS ----------
  async function fetchGrains(){
    const {data,error}=await supabase.from('Grain_for_sell').select('*').order('id');
    if(error)return console.error(error);
    grains=data;renderGrainTable();
  }
  function renderGrainTable(){
    document.getElementById("grainTable").innerHTML=grains.map(g=>`
      <tr>
        <td class="border p-2">${g.id}</td><td class="border p-2">${g.product_name}</td>
        <td class="border p-2">${g.grain||'-'}</td><td class="border p-2">${g.price_per_kg}</td>
        <td class="border p-2">${g.milling_price_per_kg}</td><td class="border p-2">${g.stock_qty}</td>
        <td class="border p-2">${g.is_active?'✅':'❌'}</td>
        <td class="border p-2"><button onclick="editGrain(${g.id})" class="px-2 py-1 bg-yellow-500 text-white rounded">Edit</button>
        <button onclick="deleteGrain(${g.id})" class="px-2 py-1 bg-red-600 text-white rounded">Delete</button></td>
      </tr>`).join('');
    document.getElementById("card-grains").innerText=grains.length;
  }
  function openGrainForm(){grainFormModal.classList.remove("hidden");grainFormTitle.innerText="Add Grain";grainProductName.value="";grainType.value="";grainPrice.value="";grainMillingPrice.value="";grainStock.value="";grainActive.checked=true;editGrainId=null;}
  function closeGrainForm(){grainFormModal.classList.add("hidden")}
  async function saveGrain(){
    const product_name=grainProductName.value.trim(),grain=grainType.value.trim(),price_per_kg=parseFloat(grainPrice.value)||0,milling_price_per_kg=parseFloat(grainMillingPrice.value)||0,stock_qty=parseInt(grainStock.value)||0,is_active=grainActive.checked;
    if(!product_name||!grain){alert("Please fill all required fields");return;}
    if(editGrainId)await supabase.from('Grain_for_sell').update({product_name,grain,price_per_kg,milling_price_per_kg,stock_qty,is_active}).eq('id',editGrainId);
    else await supabase.from('Grain_for_sell').insert([{product_name,grain,price_per_kg,milling_price_per_kg,stock_qty,is_active}]);
    closeGrainForm();fetchGrains(); refreshDashboardCountsAndStatuses();
  }
  function editGrain(id){const g=grains.find(x=>x.id===id);editGrainId=id;openGrainForm();grainProductName.value=g.product_name;grainType.value=g.grain||"";grainPrice.value=g.price_per_kg;grainMillingPrice.value=g.milling_price_per_kg;grainStock.value=g.stock_qty;grainActive.checked=g.is_active;}
  async function deleteGrain(id){if(!confirm("Delete this grain?"))return;await supabase.from('Grain_for_sell').delete().eq('id',id);fetchGrains(); refreshDashboardCountsAndStatuses();}

  // ---------- STATUS CARDS + AUTO-REFRESH + PULSE ANIMATION ----------
  const STATUS_CLASS_MAP = {
    "NEW":               "bg-yellow-100 text-yellow-800",
    "IN PROCESS":        "bg-blue-100 text-blue-800",
    "MILLING COMPLETED": "bg-green-100 text-green-800",
    "DELIVERED":         "bg-gray-200 text-gray-800",
    "PICKED UP":         "bg-purple-100 text-purple-800",
    "RECEIVED AT MILL":  "bg-orange-100 text-orange-800",
    "OUT FOR DELIVERY":  "bg-pink-100 text-pink-800",
    "ARCHIVED":          "bg-gray-100 text-gray-700"
  };

  // Desired ordering: ALL first, then these groups (missing statuses appended)
  const DESIRED_ORDER = [
    'ALL',
    'NEW',
    'RECEIVED AT MILL',
    'IN PROCESS',
    'MILLING COMPLETED',
    'PICKED UP',
    'OUT FOR DELIVERY',
    'DELIVERED',
    'ARCHIVED'
  ];

  let prevNewCount = null;
  let refreshIntervalMs = 60000;
  let refreshTimer = null;

  // WebAudio bell chime (double ding)
  function playChime() {
    try {
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (!Ctx) return; // Audio API not supported

      const ctx = new Ctx();

      // Helper: create a bell-like tone
      function playBell(freq, startOffset) {
        // Oscillator + high-frequency partial for "metallic" tone
        const osc1 = ctx.createOscillator();
        const osc2 = ctx.createOscillator();
        const gain = ctx.createGain();
        const modalFilter = ctx.createBiquadFilter();

        // oscillator waveforms
        osc1.type = 'sine';           // fundamental
        osc2.type = 'triangle';       // adds metallic overtone

        osc1.frequency.value = freq;
        osc2.frequency.value = freq * 2.01; // slight detune for shimmer

        // band-pass to make it bell-like
        modalFilter.type = 'bandpass';
        modalFilter.frequency.value = Math.max(800, freq * 1.5);
        modalFilter.Q.value = 6;

        // connect chain: oscillators -> filter -> gain -> destination
        osc1.connect(modalFilter);
        osc2.connect(modalFilter);
        modalFilter.connect(gain);
        gain.connect(ctx.destination);

        const now = ctx.currentTime + startOffset;

        // amplitude envelope: fast attack, exponential decay
        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.exponentialRampToValueAtTime(0.12, now + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.0005, now + 0.65);

        // slight pitch glide for realism
        osc1.frequency.setValueAtTime(freq * 1.01, now);
        osc1.frequency.exponentialRampToValueAtTime(freq, now + 0.12);

        // start / stop
        osc1.start(now);
        osc2.start(now);
        osc1.stop(now + 0.85);
        osc2.stop(now + 0.85);
      }

      // Play two dings: first now, second 260ms later (pleasant spacing)
      playBell(880, 0.0);    // A5-ish
      playBell(1046, 0.26);  // C6-ish - slightly higher second ding

      // close the audio context after sounds finish
      setTimeout(() => {
        try { ctx.close(); } catch (e) { /* ignore */ }
      }, 1200);

    } catch (err) {
      // fail silently if audio blocked/unavailable
      console.warn('Bell chime failed:', err);
    }
  }

  function formatTime(ts) {
    try { return new Date(ts).toLocaleString(); } catch(e) { return new Date().toLocaleString(); }
  }

  async function manualRefresh() {
    await refreshDashboardCountsAndStatuses(true);
  }

  // Build the status cards in requested order; missing statuses appended.
  async function fetchAndRenderStatusCards() {
    const container = document.getElementById('status-cards');
    container.innerHTML = `<div class="col-span-full text-sm text-gray-500">Loading...</div>`;

    // fetch statuses from DB
    const { data: statuses, error: statusErr } = await supabase.from('order_statuses').select('*').order('id');
    if(statusErr) { console.error(statusErr); container.innerHTML = `<div class="text-sm text-red-600">Failed to load statuses</div>`; return []; }

    // create a map name->id
    const statusMap = {};
    statuses.forEach(s => { statusMap[(s.status_name||'').toString().toUpperCase()] = s; });

    // prepare list following DESIRED_ORDER, include DB statuses that are not in desired list at the end
    const orderedStatusNames = [];
    DESIRED_ORDER.forEach(name => {
      if(name === 'ALL') { orderedStatusNames.push({ name: 'ALL', id: null }); return; }
      const st = statusMap[name];
      if(st) orderedStatusNames.push({ name: st.status_name, id: st.id });
    });

    // append any DB statuses not included yet
    statuses.forEach(s => {
      const up = (s.status_name||'').toString().toUpperCase();
      if(!DESIRED_ORDER.includes(up)) orderedStatusNames.push({ name: s.status_name, id: s.id });
    });

    // Now fetch counts for each ordered item. Use head:true counts for accuracy.
    const cards = [];
    for(const entry of orderedStatusNames) {
      if(entry.id === null) {
        const { count } = await supabase.from('orders').select('id', { count: 'exact', head: true });
        cards.push({ id: null, name: 'ALL', count: count || 0, badgeClass: 'bg-white text-gray-800' });
      } else {
        const { count } = await supabase.from('orders').select('id', { count: 'exact', head: true }).eq('status_id', entry.id);
        const badgeClass = STATUS_CLASS_MAP[(entry.name||'').toString().toUpperCase()] || 'bg-white text-gray-800';
        cards.push({ id: entry.id, name: entry.name, count: count || 0, badgeClass });
      }
    }

    // Render cards (no "click to filter" text)
    container.innerHTML = cards.map(c => {
      // data-status-name attribute for later detection (case-insensitive)
      return `
      <div class="bg-white p-4 rounded-lg status-card cursor-pointer" role="button"
           onclick="onStatusCardClick(${c.id === null ? 'null' : c.id})" data-status-name="${(c.name||'').toString().toUpperCase()}">
        <div class="flex items-center justify-between">
          <div>
            <div class="status-badge ${c.badgeClass} status-name">${escapeHtml(c.name)}</div>
          </div>
          <div class="text-right">
            <div class="status-count">${c.count}</div>
          </div>
        </div>
      </div>
      `;
    }).join('');

    return cards;
  }

  function escapeHtml(s) { return String(s).replace(/[&<>"']/g, (m)=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' })[m]); }

  function onStatusCardClick(statusId) {
    showSection('orders');
    if(statusId === null) fetchOrders();
    else fetchOrders(statusId);
    setTimeout(()=> { document.getElementById('section-orders').scrollIntoView({behavior:'smooth'}); }, 50);
  }

  // Main refresh function. If `manual` is true, treat as manual refresh.
  async function refreshDashboardCountsAndStatuses(manual = false) {
    try {
      const prevNew = prevNewCount;

      // top-level counts
      try {
        const { data: configsData } = await supabase.from('Configuration').select('*').order('id');
        document.getElementById("card-configs").innerText = configsData ? configsData.length : 0;
      } catch(e){ console.error(e); }
      try {
        const { data: societiesData } = await supabase.from('societies').select('*');
        document.getElementById("card-societies").innerText = societiesData ? societiesData.length : 0;
      } catch(e){ console.error(e); }
      try {
        const { data: grainsData } = await supabase.from('Grain_for_sell').select('*');
        document.getElementById("card-grains").innerText = grainsData ? grainsData.length : 0;
      } catch(e){ console.error(e); }
      try {
        const { count } = await supabase.from('orders').select('id', { count: 'exact', head: true });
        document.getElementById("card-orders").innerText = count || 0;
      } catch(e){ console.error(e); }
      try {
        const { data: usersData } = await supabase.from('customers').select('*');
        document.getElementById("card-users").innerText = usersData ? usersData.length : 0;
      } catch(e){ console.error(e); }

      // fetch and render status cards
      const cards = await fetchAndRenderStatusCards();

      // find NEW card count
      const newCard = cards.find(c => (c.name||'').toString().toUpperCase() === 'NEW');
      const currentNewCount = newCard ? (Number(newCard.count) || 0) : 0;

      // if increase -> chime + pulse animation on NEW card
      if (prevNewCount !== null && currentNewCount > prevNewCount) {
        playChime();
        // add pulse class to NEW card element
        try {
          const nodes = document.querySelectorAll('#status-cards [data-status-name="NEW"]');
          nodes.forEach(n => {
            // add pulse to badge inside (badge is first child .status-badge)
            const badge = n.querySelector('.status-badge');
            if(badge) {
              badge.classList.add('pulse');
              // remove after animation
              setTimeout(()=> badge.classList.remove('pulse'), 2600);
            }
            // also add a subtle highlight to the card
            n.classList.add('ring-2', 'ring-yellow-300');
            setTimeout(()=> n.classList.remove('ring-2','ring-yellow-300'), 2600);
          });
        } catch(e) { console.warn('pulse failed', e); }
      }

      prevNewCount = currentNewCount;

      // update last refreshed timestamp
      document.getElementById('last-refresh').innerText = `Last refreshed: ${formatTime(new Date())}`;

    } catch (err) {
      console.error('Dashboard refresh failed', err);
    }
  }

  // start refresh loop and initial load
  refreshDashboardCountsAndStatuses();
  function startAutoRefresh() {
    if (refreshTimer) clearInterval(refreshTimer);
    refreshTimer = setInterval(()=> refreshDashboardCountsAndStatuses(false), refreshIntervalMs);
  }
  startAutoRefresh();

  // Ensure after operations we refresh dashboard counts
  async function deleteOrder(id){
    if(!confirm('Delete order?')) return;
    await supabase.from('orders').delete().eq('id',id);
    await fetchOrders();
    await refreshDashboardCountsAndStatuses();
  }

  // ---------- Archive Delivered Orders older than 3 days ----------
  function showAdminToast(msg, duration = 3500) {
    try {
      const t = document.getElementById('admin-toast');
      if (!t) { alert(msg); return; }
      t.textContent = msg;
      t.classList.remove('hidden');
      t.style.opacity = '1';
      clearTimeout(t._hideTimeout);
      t._hideTimeout = setTimeout(() => {
        t.style.opacity = '0';
        setTimeout(() => t.classList.add('hidden'), 300);
      }, duration);
    } catch (e) {
      console.warn('Toast failed', e);
    }
  }

  /**
   * Archive all Delivered orders older than 3 days.
   * Uses delivered_at field (preferred) as per your schema.
   */

async function archiveOldDeliveredOrders() {
  const btn = document.getElementById('archive-orders-btn');
  if (btn) {
    btn.disabled = true;
    var originalText = btn.textContent;
    btn.textContent = "Archiving...";
  }

  try {
    // 1️⃣ Step 1: Get ARCHIVED status id if exists
    let { data: existing, error: findErr } = await supabase
      .from("order_statuses")
      .select("id")
      .eq("status_name", "ARCHIVED")
      .maybeSingle();

    let archivedId = existing?.id || null;

    // 2️⃣ Step 2: If ARCHIVED does NOT exist → create it safely
    if (!archivedId) {
      try {
        // Find max sort_order
        const { data: maxRow, error: maxErr } = await supabase
          .from("order_statuses")
          .select("sort_order")
          .order("sort_order", { ascending: false })
          .limit(1)
          .maybeSingle();

        if (maxErr) throw maxErr;

        const currentMax = (maxRow && typeof maxRow.sort_order === "number")
          ? maxRow.sort_order
          : 0;

        const nextSortOrder = currentMax + 1;

        // Insert ARCHIVED status with required sort_order
        const { data: newArch, error: insertErr } = await supabase
          .from("order_statuses")
          .insert([{ status_name: "ARCHIVED", sort_order: nextSortOrder }])
          .select("id")
          .limit(1)
          .maybeSingle();

        if (insertErr) throw insertErr;

        archivedId = newArch?.id;

        if (!archivedId) throw new Error("ARCHIVED insert returned no id");
      } catch (e) {
        console.error("Error creating ARCHIVED status:", e);
        showAdminToast("Failed to create ARCHIVED status.");
        if (btn) { btn.disabled = false; btn.textContent = originalText; }
        return;
      }
    }

    // 3️⃣ Step 3: Find delivered orders > 3 days old
    const threeDaysAgo = new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString();

    const { data: oldDelivered, error: fetchErr } = await supabase
      .from("orders")
      .select("id, delivered_at")
      .eq("status_backup", "DELIVERED")
      .lt("delivered_at", threeDaysAgo);

    if (fetchErr) throw fetchErr;

    if (!oldDelivered || oldDelivered.length === 0) {
      showAdminToast("No delivered orders older than 3 days.");
      if (btn) { btn.disabled = false; btn.textContent = originalText; }
      return;
    }

    // Extract list of ids
    const ids = oldDelivered.map(o => o.id);

    // 4️⃣ Step 4: Update orders → ARCHIVED
    const { error: updErr } = await supabase
      .from("orders")
      .update({
        status_id: archivedId,
        status_backup: "ARCHIVED"
      })
      .in("id", ids);

    if (updErr) throw updErr;

    showAdminToast(`Archived ${ids.length} orders.`);
    
    // Refresh dashboard
    await refreshDashboardCountsAndStatuses();

  } catch (err) {
    console.error("archiveOldDeliveredOrders failed:", err);
    showAdminToast("Archiving failed.");
  }

  // Restore button
  if (btn) {
    btn.disabled = false;
    btn.textContent = originalText;
  }
}


    
//   async function archiveOldDeliveredOrders() {
//     if (!confirm('Archive all Delivered orders older than 3 days? This will change their status to ARCHIVED.')) return;

//     const btn = document.getElementById('archive-btn');
//     const originalText = btn ? btn.textContent : null;
//     if (btn) { btn.disabled = true; btn.textContent = 'Archiving...'; }

//     try {
//       // 1) find delivered status id (case-insensitive)
//       const { data: deliveredRow, error: dErr } = await supabase
//         .from('order_statuses')
//         .select('id, status_name')
//         .ilike('status_name', 'DELIVERED')
//         .limit(1)
//         .maybeSingle();

//       if (dErr) throw dErr;
//       if (!deliveredRow || !deliveredRow.id) {
//         showAdminToast('DELIVERED status not found — aborting.');
//         return;
//       }
//       const deliveredId = deliveredRow.id;

//       // 2) find archived status id (create if not exists)
//       let { data: archivedRow, error: aErr } = await supabase
//         .from('order_statuses')
//         .select('id, status_name')
//         .ilike('status_name', 'ARCHIVED')
//         .limit(1)
//         .maybeSingle();

//       if (aErr) throw aErr;

//       let archivedId = archivedRow?.id ?? null;

//       if (!archivedId) {
//         // create ARCHIVED status
//     // create ARCHIVED status (safe: compute next sort_order from existing rows)
// try {
//   // find current max sort_order (get highest sort_order row)
//   const { data: maxRow, error: maxErr } = await supabase
//     .from('order_statuses')
//     .select('sort_order')
//     .order('sort_order', { ascending: false })
//     .limit(1)
//     .maybeSingle();

//   if (maxErr) throw maxErr;

//   const currentMaxSort = (maxRow && typeof maxRow.sort_order === 'number') ? maxRow.sort_order : 0;
//   const nextSortOrder = currentMaxSort + 1;

//   const { data: newArch, error: createErr } = await supabase
//     .from('order_statuses')
//     .insert([{ status_name: 'ARCHIVED', sort_order: nextSortOrder }])
//     .select('id')
//     .limit(1)
//     .maybeSingle();

//   if (createErr) {
//     console.error('Failed to create ARCHIVED status', createErr);
//     showAdminToast('Failed to create ARCHIVED status. See console.');
//     return;
//   }
//   archivedId = newArch?.id;
//   if (!archivedId) {
//     showAdminToast('Could not determine ARCHIVED status id. Aborting.');
//     return;
//   }
// } catch (e) {
//   console.error('Error creating ARCHIVED status (with sort_order):', e);
//   showAdminToast('Failed to create ARCHIVED status. See console.');
//   return;
// }


//         if (createErr) {
//           console.error('Failed to create ARCHIVED status', createErr);
//           showAdminToast('Failed to create ARCHIVED status. See console.');
//           return;
//         }
//         archivedId = newArch?.id;
//         if (!archivedId) {
//           showAdminToast('Could not determine ARCHIVED status id. Aborting.');
//           return;
//         }
//       }

//       // 3) compute cutoff timestamp (ISO)
//       const cutoff = new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString();

//       // 4) perform update: set status_id = archivedId for delivered orders with delivered_at <= cutoff
//       // Also update status_backup to 'archived'
//       const { data: updatedRows, error: updateErr } = await supabase
//         .from('orders')
//         .update({ status_id: archivedId, status_backup: 'archived' })
//         .eq('status_id', deliveredId)
//         .lte('delivered_at', cutoff)
//         .select('id');

//       if (updateErr) {
//         console.error('Archive update failed:', updateErr);
//         showAdminToast('Archive operation failed — check console.');
//       } else {
//         const changed = Array.isArray(updatedRows) ? updatedRows.length : 0;
//         showAdminToast(`${changed} Delivered order(s) archived.`);
//         // refresh UI counts & status cards
//         await refreshDashboardCountsAndStatuses();
//         // if orders table visible, refresh it too
//         if (!document.getElementById('section-orders').classList.contains('hidden')) {
//           await fetchOrders();
//         }
//       }
//     } catch (err) {
//       console.error('archiveOldDeliveredOrders failed:', err);
//       showAdminToast('Unexpected error during archiving. See console.');
//     } finally {
//       if (btn) { btn.disabled = false; btn.textContent = originalText; }
//     }
//   }

  // call refresh when operations change data (e.g., after saving configs/grains etc.)
  // existing saveConfig/saveGrain/saveSociety functions already call refreshDashboardCountsAndStatuses()

  </script>
</body>
</html>

