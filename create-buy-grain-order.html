<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>New Order</title>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

  <style>
    body { font-family: "Inter", system-ui, sans-serif; }
    /* Make header compact */
    .page-header { padding: 6px 0; margin-bottom: 8px; }
    .user-card { font-size: 13px; }
    .summary-card { font-size: 13px; }
    /* Hide large outer white card look by keeping separate cards */
    .outer-card { background: transparent; box-shadow: none; padding: 0; }
    /* Hide visible grand total row, keep hidden element available for logic */
    .grand-total-row { display: none; }
  </style>
  <script defer src="/common.js"></script>
</head>
<body class="bg-gray-50 min-h-screen p-4">
  <div class="max-w-3xl mx-auto outer-card">

    <!-- Small header -->
    <header class="page-header">
      <h2 class="text-lg font-semibold">New Order</h2>
    </header>

    <!-- USER CARD (compact) -->
    <section id="user-info" class="bg-white rounded-xl p-4 mb-4 user-card border">
      <!-- Will be populated by loadUser() with masked view and data-raw attributes -->
      <div class="space-y-1">
        <div><strong class="text-sm">Name:</strong> <span id="ui-name" data-raw=""></span></div>
        <div><strong class="text-sm">Mobile:</strong> <span id="ui-mobile" data-raw=""></span></div>
        <div><strong class="text-sm">Flat / Wing:</strong> <span id="ui-flat" data-raw=""></span></div>
        <div><strong class="text-sm">Society:</strong> <span id="ui-society" data-raw=""></span></div>
      </div>
    </section>

    <!-- Order Type Summary (moved below header as in original) -->
    <div id="selection-summary" class="mb-3 text-sm hidden">
      <strong class="text-sm">Order Type:</strong>
      <span id="selection-summary-text" class="text-indigo-600"></span>
    </div>

    <!-- Inline info -->
    <div id="delivery-info" class="mb-3" style="display:none;">
      <div role="status" aria-live="polite" class="inline-flex items-start gap-3 rounded-md bg-blue-50 border border-blue-100 px-3 py-2 text-sm text-blue-800">
        <svg class="w-4 h-4 flex-shrink-0 mt-0.5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
          <path fill-rule="evenodd" d="M18 10A8 8 0 1 1 2 10a8 8 0 0 1 16 0zm-8-4a1 1 0 1 0 0 2 1 1 0 0 0 0-2zm1 8a1 1 0 0 1-2 0v-4a1 1 0 0 1 2 0v4z" clip-rule="evenodd"/>
        </svg>
        <div class="leading-tight">
          <span class="font-medium">Delivery timings:</span>
          <span class="ml-1">7pm to 9pm every day — orders booked before 5pm will be delivered same day.</span>
        </div>
      </div>
    </div>

    <hr class="my-3">

    <!-- ORDER ROWS (grains): your loadGrains() will append rows here as before -->
    <div id="order-rows" class="space-y-4 mb-4"></div>

    <!-- Order Summary (separate card) -->
    <div class="bg-white p-4 rounded-lg mb-4 summary-card border">
      <h3 class="font-semibold mb-1 text-sm">Order Summary</h3>
      <p class="text-xs text-gray-500 mb-2">*Values are rounded off to the nearest number</p>

      <div class="flex justify-between text-gray-600 text-sm">
        <span>Selected Items</span>
        <span id="total-items">0</span>
      </div>
      <div class="flex justify-between text-gray-600 text-sm">
        <span>Total Quantity</span>
        <span id="total-qty">0 kg</span>
      </div>
      <div class="flex justify-between text-gray-600 text-sm">
        <span>Milling Charges</span>
        <span>₹<span id="milling-total">0</span></span>
      </div>

      <!-- Delivery Charges (NEW) -->
      <div id="delivery-row" class="flex justify-between text-gray-600 text-sm" style="display:none;">
        <span>Delivery Charges</span>
        <span>₹<span id="delivery-cost">0</span></span>
      </div>

      <!-- Visible Total Price (this will now include delivery charge i.e. grand total) -->
      <div class="flex justify-between font-bold text-base border-t pt-2 mt-2">
        <span>Total Price</span>
        <span>₹<span id="total-price">0</span></span>
      </div>

      <!-- Kept for business logic but hidden from UI -->
      <div class="grand-total-row">
        <div class="flex justify-between font-bold text-lg border-t pt-2 mt-3">
          <span>Grand Total</span>
          <span>₹<span id="grand-total">0</span></span>
        </div>
      </div>
    </div>

    <div class="flex space-x-3">
      <button id="submit-btn" onclick="submitOrder()" class="flex-1 bg-indigo-600 text-white py-2 px-4 rounded-lg hover:bg-indigo-700">
        Create Order
      </button>

      <button onclick="history.back()" class="flex-1 border border-gray-300 py-2 px-4 rounded-lg hover:bg-gray-100">
        Back
      </button>
    </div>

  </div>

  <!-- Toast -->
  <div id="toast" class="hidden fixed bottom-5 right-5 bg-green-600 text-white px-4 py-2 rounded shadow"></div>

  <script src="config.js"></script>

  <script type="module">
    import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm';

    const SUPABASE_URL = window._env_.SUPABASE_URL;
    const SUPABASE_KEY = window._env_.SUPABASE_ANON_KEY;
  
    const supabase = createClient(SUPABASE_URL, SUPABASE_KEY);

    const urlParams = new URLSearchParams(window.location.search);
    const phone = urlParams.get('phone');
    let user = null;
    let deliveryCharge = 0;
    let isSubmitting = false;

    const orderRows = document.getElementById("order-rows");
    const totalItemsEl = document.getElementById("total-items");
    const totalQtyEl = document.getElementById("total-qty");
    const millingTotalEl = document.getElementById("milling-total");
    const totalPriceEl = document.getElementById("total-price");
    const grandTotalEl = document.getElementById("grand-total"); // kept for logic
    const toast = document.getElementById("toast");
    const deliveryRowEl = document.getElementById("delivery-row");
    const deliveryCostEl = document.getElementById("delivery-cost");
    const selectionSummaryEl = document.getElementById("selection-summary");
    const selectionSummaryTextEl = document.getElementById("selection-summary-text");
    const deliveryInfoEl = document.getElementById("delivery-info");

    function showToast(message, type = "success") {
      toast.textContent = message;
      toast.className = `fixed bottom-5 right-5 px-4 py-2 rounded shadow text-white ${
        type === "success" ? "bg-green-600" : "bg-red-600"
      }`;
      toast.style.display = "block";
      setTimeout(() => { toast.style.display = "none"; }, 3000);
    }

    function computeSelectionSummary() {
      const serveAt = localStorage.getItem('serveAt') || '';
      const orderType = (localStorage.getItem('orderType') || '').toLowerCase();

      if (orderType.includes('home') && orderType.includes('buy')) return "Home delivery — Atta Order";
      if (orderType.includes('shop') && orderType.includes('buy')) return "At shop — Atta Order";
      if (orderType.includes('home')) return "Home delivery — Pickup & Drop";
      if (orderType.includes('shop')) return "At shop — Pickup & Drop";

      return serveAt.toLowerCase().includes('home') ? "Home delivery" : "At shop";
    }

    function updateSelectionSummaryDisplay() {
      const text = computeSelectionSummary();
      const el = document.getElementById("selection-summary");
      const infoBox = document.getElementById("delivery-info");

      document.getElementById("selection-summary-text").textContent = text;
      el.style.display = text ? "block" : "none";

      // Show delivery info ONLY when home delivery
      const lower = text.toLowerCase();
      if (lower.includes("home")) {
        infoBox.style.display = "block";
      } else {
        infoBox.style.display = "none";
      }
    }

    /* Masking utility used for user display only (raw value preserved in data-raw attribute) */
    function maskValue(value, left = 1, right = 1) {
      if (!value) return '';
      const s = String(value);
      if (s.length <= left + right + 2) {
        return s.slice(0, left) + '*'.repeat(Math.max(2, s.length - left));
      }
      const leftPart = s.slice(0, left);
      const rightPart = s.slice(s.length - right);
      const mid = '*'.repeat(Math.max(3, s.length - left - right));
      return leftPart + mid + rightPart;
    }

    async function loadUser() {
      const { data } = await supabase
        .from("customers")
        .select("*")
        .eq("phone_number", phone)
        .maybeSingle();

      user = data;

      // Preserve raw values in data-raw and show masked values to user
      const uiName = document.getElementById('ui-name');
      const uiMobile = document.getElementById('ui-mobile');
      const uiFlat = document.getElementById('ui-flat');
      const uiSociety = document.getElementById('ui-society');

      const rawName = user?.name || '';
      const rawPhone = user?.phone_number || '';
      const rawFlat = `${user?.flat_number || ''}${user?.wing ? ', ' + user.wing : ''}`.trim();
      const rawSociety = user?.society_name || '';

      uiName.setAttribute('data-raw', rawName);
      uiMobile.setAttribute('data-raw', rawPhone);
      uiFlat.setAttribute('data-raw', rawFlat);
      uiSociety.setAttribute('data-raw', rawSociety);

      // Display masked versions (few chars + stars)
      uiName.textContent = maskValue(rawName, 1, 1);
      uiMobile.textContent = maskValue(rawPhone, 2, 2);
      uiFlat.textContent = maskValue(rawFlat, 1, 1);
      uiSociety.textContent = maskValue(rawSociety, 1, 1);

      updateSelectionSummaryDisplay();
    }

    async function loadGrains() {
      const { data: grains } = await supabase
        .from("Grain_for_sell")
        .select("*")
        .eq("is_active", true);

      grains.forEach(g => {
        const row = document.createElement("div");
        row.className = "p-3 border rounded-lg shadow-sm bg-gray-50 space-y-2";

        row.innerHTML = `
          <div class="flex items-center gap-3">
            <input type="checkbox" class="grain-check"/>
            <div class="grain-name flex-1 font-semibold">${g.product_name}</div>
            <input type="number" min="1" placeholder="Qty (kg)" class="grain-qty w-20 p-2 border rounded"/>
          </div>
          <div class="flex flex-col text-sm text-gray-700">
            <span class="price" data-price="${g.price_per_kg}">Grain Price: ₹${g.price_per_kg}/kg</span>
            <span class="milling" data-milling="${g.milling_price_per_kg || 0}">Milling Price: ₹${g.milling_price_per_kg || 0}/kg</span>
            <span>Total: ₹<span class="row-total">0</span></span>
          </div>
          <div class="error text-red-500 text-sm"></div>
        `;

        const check = row.querySelector(".grain-check");
        const qtyInput = row.querySelector(".grain-qty");
        const errorEl = row.querySelector(".error");

        check.addEventListener("change", () => {
          errorEl.textContent = "";
          if (!check.checked) qtyInput.value = "";
          updateTotals();
        });

        qtyInput.addEventListener("input", () => {
          if (qtyInput.value > 0) check.checked = true;
          updateTotals();
        });

        orderRows.appendChild(row);
      });
    }

    function updateTotals() {
      let totalItems = 0, totalQty = 0, totalPrice = 0, millingTotal = 0;

      [...orderRows.querySelectorAll(".p-3")].forEach(row => {
        const check = row.querySelector(".grain-check");
        const qtyInput = row.querySelector(".grain-qty");
        const totalEl = row.querySelector(".row-total");
        const price = parseFloat(row.querySelector(".price").dataset.price);
        const milling = parseFloat(row.querySelector(".milling").dataset.milling);

        if (check.checked && qtyInput.value > 0) {
          const qty = parseFloat(qtyInput.value);
          const rowTotal = (price + milling) * qty;
          totalEl.textContent = rowTotal.toFixed(2);

          totalItems++;
          totalQty += qty;
          totalPrice += rowTotal;
          millingTotal += milling * qty;
        } else {
          totalEl.textContent = "0";
        }
      });

      totalItemsEl.textContent = totalItems;
      totalQtyEl.textContent = totalQty;
      millingTotalEl.textContent = Math.round(millingTotal);

      // Set visible total to subtotal for now; updateDeliveryCharge will add delivery and set final visible total
      totalPriceEl.textContent = Math.round(totalPrice);

      // compute delivery charge using totalPrice and totalQty (weight)
      updateDeliveryCharge(totalPrice);
    }

    /**
     * Fetch per-kg delivery rate from your Configuration table:
     * public."Configuration" with config_key = 'delivery_per_kg'
     * Returns numeric rate (e.g. 2) or null if not found/invalid.
     */
    async function fetchPerKgRateFromConfig() {
      try {
        const { data, error } = await supabase
          .from('Configuration')
          .select('config_value')
          .eq('config_key', 'delivery_per_kg')
          .limit(1)
          .maybeSingle();

        const row = data ?? null;
        if (!error && row && row.config_value != null) {
          const v = Number(row.config_value);
          if (!isNaN(v)) return v;
        }
      } catch (e) {
        // ignore
      }
      return null;
    }

    async function updateDeliveryCharge(subtotal) {
      const serveAt = (localStorage.getItem('serveAt') || '').toLowerCase();

      // if not home delivery, keep existing behaviour: no delivery
      if (!serveAt.includes('home')) {
        deliveryCharge = 0;
        deliveryRowEl.style.display = 'none';
        deliveryCostEl.textContent = `0`;

        // update visible total price to be the final amount (no delivery)
        totalPriceEl.textContent = Math.round(subtotal);
        grandTotalEl.textContent = Math.round(subtotal); // preserve for logic
        return;
      }

      // compute total weight from rows (kg)
      let totalWeight = 0;
      [...orderRows.querySelectorAll(".p-3")].forEach(row => {
        const check = row.querySelector(".grain-check");
        const qtyInput = row.querySelector(".grain-qty");
        if (check.checked && qtyInput.value) {
          const q = parseFloat(qtyInput.value) || 0;
          totalWeight += q;
        }
      });

      const deliveryTypeKey = 'normal';
      let foundPrice = null;

      try {
        if (totalWeight <= 5) {
          const societyId = user?.society_id || null;

          if (societyId) {
            const { data } = await supabase
              .from("delivery_pricing")
              .select("price")
              .eq("delivery_type", deliveryTypeKey)
              .eq("is_active", true)
              .eq("society_id", societyId)
              .maybeSingle();

            if (data?.price != null) foundPrice = Number(data.price);
          }

          if (foundPrice == null) {
            const { data } = await supabase
              .from("delivery_pricing")
              .select("price")
              .eq("delivery_type", deliveryTypeKey)
              .eq("is_active", true)
              .is("society_id", null)
              .maybeSingle();

            if (data?.price != null) foundPrice = Number(data.price);
          }

          if (foundPrice == null) {
            const { data } = await supabase
              .from("delivery_pricing")
              .select("price")
              .eq("delivery_type", deliveryTypeKey)
              .eq("is_active", true)
              .limit(1);

            if (data?.[0]?.price != null) foundPrice = Number(data[0].price);
          }

          deliveryCharge = foundPrice || 0;
        } else {
          const perKg = await fetchPerKgRateFromConfig();

          if (perKg != null && !isNaN(perKg)) {
            deliveryCharge = Number(perKg) * Number(totalWeight);
          } else {
            const societyId = user?.society_id || null;

            if (societyId) {
              const { data } = await supabase
                .from("delivery_pricing")
                .select("price")
                .eq("delivery_type", deliveryTypeKey)
                .eq("is_active", true)
                .eq("society_id", societyId)
                .maybeSingle();

              if (data?.price != null) foundPrice = Number(data.price);
            }

            if (foundPrice == null) {
              const { data } = await supabase
                .from("delivery_pricing")
                .select("price")
                .eq("delivery_type", deliveryTypeKey)
                .eq("is_active", true)
                .is("society_id", null)
                .maybeSingle();

              if (data?.price != null) foundPrice = Number(data.price);
            }

            if (foundPrice == null) {
              const { data } = await supabase
                .from("delivery_pricing")
                .select("price")
                .eq("delivery_type", deliveryTypeKey)
                .eq("is_active", true)
                .limit(1);

              if (data?.[0]?.price != null) foundPrice = Number(data[0].price);
            }

            deliveryCharge = foundPrice || 0;
          }
        }
      } catch (err) {
        deliveryCharge = 0;
      }

      // Update UI
      if (deliveryCharge > 0) {
        deliveryRowEl.style.display = 'flex';
        deliveryCostEl.textContent = deliveryCharge;
      } else {
        deliveryRowEl.style.display = 'none';
        deliveryCostEl.textContent = 0;
      }

      // update grand total (kept hidden) and show final amount in visible Total Price
      const final = Math.round(subtotal + (deliveryCharge || 0));
      grandTotalEl.textContent = final;      // kept for your submit logic
      totalPriceEl.textContent = final;      // visible single total for user
    }

    window.submitOrder = async function () {
      if (isSubmitting) return;
      isSubmitting = true;

      const btn = document.getElementById("submit-btn");
      btn.disabled = true;
      btn.textContent = "Processing...";

      let grainDetails = [];
      let hasError = false;

      [...orderRows.querySelectorAll(".p-3")].forEach(row => {
        const check = row.querySelector(".grain-check");
        if (!check.checked) return;

        const qtyInput = row.querySelector(".grain-qty");
        const name = row.querySelector(".grain-name").textContent.trim();
        const price = parseFloat(row.querySelector(".price").dataset.price);
        const milling = parseFloat(row.querySelector(".milling").dataset.milling);
        const qty = parseFloat(qtyInput.value || 0);
        const total = (price + milling) * qty;

        if (qty <= 0) hasError = true;
        else grainDetails.push({ grain: name, quantity: qty, price, milling, total });
      });

      if (hasError || grainDetails.length === 0) {
        showToast("Fix errors before submitting", "error");
        btn.disabled = false;
        btn.textContent = "Create Order";
        isSubmitting = false;
        return;
      }

      const subtotal = Number(totalPriceEl.textContent);
      const grandTotal = Number(grandTotalEl.textContent);

      const inactiveStatuses = ["DELIVERED", "CANCELLED", "REJECTED"];

      async function generateTokenNumber() {
        const { data: activeOrders } = await supabase
          .from("orders")
          .select("token_number, order_statuses!inner(status_name)")
          .not("order_statuses.status_name", "in", `(${inactiveStatuses.map(s => `'${s}'`).join(",")})`);

        const activeTokens = new Set(activeOrders.map(o => o.token_number));
        let maxTokenNum = 0;

        activeTokens.forEach(token => {
          const num = parseInt(token.slice(2), 10);
          if (num > maxTokenNum) maxTokenNum = num;
        });

        for (let i = 1; i <= 999; i++) {
          let next = maxTokenNum + i;
          if (next > 999) next -= 999;
          const token = `QA${next}`;
          if (!activeTokens.has(token)) return token;
        }
      }

      const token = await generateTokenNumber();

      const { data: statusData } = await supabase
        .from("order_statuses")
        .select("id")
        .eq("status_name", "NEW")
        .maybeSingle();

      const statusId = statusData?.id || null;

      const { error } = await supabase.from("orders").insert([{
        customer_id: user.id,
        grain_details: grainDetails,
        total_price: grandTotal,
        token_number: token,
        order_type: localStorage.getItem("orderType") || "",
        serve_at: localStorage.getItem("serveAt") || "",
        status_id: statusId
      }]);

      if (error) {
        showToast("❌ Failed to place order", "error");
        btn.disabled = false;
        btn.textContent = "Create Order";
        isSubmitting = false;
        return;
      }

      showToast("✅ Order placed! Token: " + token);
      setTimeout(() => {
        window.location.href = '/my-orders.html?phone=' + phone + '&token=' + token;
      }, 1500);
    };

    loadUser();
    loadGrains();
  </script>
</body>
</html>
